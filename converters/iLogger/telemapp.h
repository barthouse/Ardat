#ifndef TELEMAPP_H_INCLUDED
#define TELEMAPP_H_INCLUDED
/*
 * Copyright (c) 2008 iRacing.com Motorsport Simulations, LLC.  
 *
 * Date			Who		What
 * 04-oct-2005	RJC		Brought into the FIRST environment
 * 05-apr-2002	RJC 	Created
 *
 ***************************************************************************
 *	
 *	Terminology:
 *		"The App" - refers to the telemetry gathering application
 *		"The Sim" - refers to the iRacing racing simulator
 *		"Telemetry" - refers to any data sent to the app by the sim
 *		"State data" - refers to a specific type of telemetry that
 *			identifies changes in the sim's state (like the sim
 *			has paused or unpaused, or a track has been loaded or
 *			unloaded).
 *		"Sample data" - refers to telemetry data that is generated
 *			each evenly-spaced time period (like the car's orientation
 *			and velocity, or the player's control inputs)
 *		"A sample" - refers to a set of sample data that was all
 *			generated by the sim at the same point in time in the
 *			simulated world.
 *	
 *	Overview:
 *	---------
 *	
 *	An app can tie into the iRacing simulator and gather telemetry
 *	from the sim as the sim is running.
 *	
 *	While the sim is running, it periodically checks to see whether
 *	an external telemetry application is running.  If ir finds one,
 *	the sim will establish communications with the app, and write
 *	telemetry (sample and state data) to the app as needed.
 *	
 *	The sim can only send telemetry to one external application at
 *	any given time.  If a second app tries to register itself as a
 *	gatherer, the attempt to register will fail.
 *	
 *	Once the app has begun, it can make certain requests to the sim
 *	(such as  indicating the types of telemetry in which it is interested).
 *	
 *	Once the sim has begun, it will process any such requests from
 *	the app.  The sim will also write both state data and sample data
 *	to the app as the data becomes available.  Examples of state
 *	data would be notifications whenever a track is loaded or
 *	unloaded, or whenever the player pauses or unpauses the sim.
 *	Examples of sample data would be the chassis velocity and
 *	orientation, and the player input (throttle, brake, etc.).
 *	
 *	The app must be capable of reading the telemetry from the sim
 *	at least as quickly as the sim generates it.  As of this writing,
 *	if all telemetry is turned on the sim will be spitting data
 *	at the app at close to 360Hz, and will generate on the order of
 *	100Kbytes per second of data.  Typically, though, it will only
 *	spit data at 60Hz, generating on the order of a few Kbytes per
 *	second.
 *	
 *	The buffer into which the telemetry is written is of a limited
 *	size, so the app will need to quickly process the data to keep
 *	the buffer from overflowing. If the buffer does overflow,
 *	nothing catastrophic will happen.  The sim will continue to run,
 *	but it will stop writing data until space becomes available in
 *	the buffer, and so some telemetry will be lost.  The app will
 *	be able to query whether the buffer has overflowed.
 *	
 *	
 *	More detail:
 *	------------
 *	
 *	All of the data types, functions, etc. in the iRacing telemetry
 *	API are in the namespace iRacingTelem.  As such, you'll need to
 *	either qualify your use of the API components, or issue a
 *		using namespace iRacingTelem;
 *	directive.
 *	
 *	The app indicates its desire to be a telemetry gatherer by
 *	calling the AppBegin() function, specifying the name of the
 *	simulator to which it wants to attach ("iRacing.com Simulator").
 *	If this function succeeds, it will return true, and the app
 *	is then obliged to call AppEnd() before exiting.  The app
 *	should not call AppEnd() if it did not successfully call
 *	AppBegin().
 *	
 *	The system works by using a shared memory area to which
 *	both the app and the sim have access.  AppBegin() is the
 *	routine that creates this shared memory area.  While the
 *	sim is running, it periodically tries to execute its corresponding
 *	SimBegin() routine, which looks to see if this shared memory
 *	area exists.  Requests made by the app are written into a
 *	queue in one part of this shared memory, and telemetry
 *	generated by the sim is written into a queue in another
 *	part of this memory.
 *	
 *	Once begun, the app can use the AppRequestDataItems() function
 *	to indicate to the sim what sample and/or state data it is
 *	interested in receiving.  It does not have to wait for the
 *	sim to start up before issuing this request.
 *	
 *	The simulator program updates its world at 60Hz.  This rate
 *	is fine for most things, but it isn't nearly sufficient for
 *	running the physics simulation.  To achieve the desired
 *	fidelity in the physics simulation, the simulator runs the
 *	physics a number of times each 60th of a second.  As of this
 *	writing, it runs the physics 6 times each 60th of a second,
 *	resulting in an underlying physics rate of 360Hz.  By default,
 *	the telemetry system will sample the physics at the 60Hz world
 *	update rate.  The app can use the AppRequestDataAtPhysicsRate()
 *	function to request data at the full 360Hz rate.  This will,
 *	obviously, generate 6 times the amount of data.
 *	
 *	By using AppRequestDataItems(), the app can ask for any of the
 *	data types listed in the eSimDataType enum, except those
 *	specifically noted.  The item types listed before
 *	kNoStateInfo are considered "sample" items.  Those that
 *	have been requested are generated as a group each 60th
 *	(or 360th) of a second.  While the system does not force
 *	you to do so, you should always request kSampleHeader if
 *	you also request any other sample item.  Items below
 *	kNoStateInfo are considered "state" items.  Those that have
 *	been requested are generated by the sim as needed.
 *
 *	Player car gauge data is sampled at 60Hz, even when 360Hz
 *	is the selected sample rate.  
 *	
 *	The heart of the system is the AppWaitForNewSample()
 *	function.  Calling AppWaitForNewSample() will
 *	read telemetry items from the sim until either a complete
 *	sample has been read, or a state item has been read, or
 *	the specified timeout has expired (approximate - do NOT
 *	use the timeout facility of this function to try to get
 *	your app to do something on an even time schedule).
 *	Specifying a zero timeout will cause AppWaitForNewSample
 *	to return immediately if neither a sample nor a bit of
 *	state telemetry is available.  If a complete sample has
 *	been read, AppWaitForNewSample will return true.
 *
 *	The telemetry system has buffers that will hold one of
 *	each type of telemetry item.  When AppWaitForNewSample
 *	reads a telemetry item from the sim, it stores it in the
 *	buffer for that item type, and sets an internal flag
 *	indicating that the app can query that item.  The app
 *	can call AppGetSimData, specifying the item type,
 *	to get at the data.  It will return a pointer to the data
 *	item if it is available, or NULL otherwise.
 *	
 *	Any of these item buffers could be overwritten the
 *	next time the app calls AppWaitForNewSample, so the app
 *	should NOT maintain pointers obtained from AppGetSimData
 *	across calls to AppWaitForNewSample.  The app may
 *	explicitly clear a particular item type by calling
 *	AppClearSimData for that type, or it can clear all sample
 *	items by calling AppClearSample
 *
 *	When AppWaitForNewSample returns true, the app can then call
 *	AppGetSimData() repeatedly, specifying the eSimDataType items
 *	it has requested, to access the sample data.  Once the app
 *	is done with this sample, it should call AppClearSample()
 *	to ensure that it can not inadvertently re-read part of this
 *	sample again.
 *	
 *	Note that since calling AppRequestDataItems() is asynchronous
 *	to the sim's telemetry generation, the app cannot assume
 *	that the next sample it reads after having called this
 *	function will reflect this request.  Thus, the app should
 *	ALWAYS test that AppGetSimData() has returned a non-NULL
 *	pointer.
 *	
 *	When AppWaitForNewSample() returns false, it will either be
 *	because the timeout expired, or a piece of state data was
 *	read, in which case its newStateData output parameter will
 *	be set to the eSimDataType enum identifying the piece of
 *	state data that was read from the sim.  The app can then
 *	call AppGetSimData() with this type to see the new state data.
 *	Note that calling AppClearSample() clears only sample data,
 *	not state data.
 *	
 *	
 *	Important notes:
 *	----------------
 *	
 *	The sim can generate telemetry at a high rate.  The buffer
 *	into which the telemetry is written is not particularly
 *	large, so the app must be prepared to read the telemetry
 *	quickly.  If the app falls behind and the buffer overflows,
 *	the sim will have to discard some telemetry.  When this
 *	happens, it's possible that only part of a sample will be
 *	written (though the sim will never write only part of a
 *	specific data item).  The app must be prepared to deal
 *	with partial samples.
 *	
 *	By default, the sim runs as a HIGH_PRIORITY_CLASS process.
 *	The sim is multi-threaded, and it runs all of its real-time
 *	threads at at least THREAD_PRIORITY_ABOVE_NORMAL.  All of
 *	these real-time threads run on a time schedule and will
 *	cooperatively put themselves to sleep when their processing
 *	of the current sim loop is complete.  The sim also has a
 *	non-real-time thread that it runs at THREAD_PRIORITY_BELOW_NORMAL.
 *	This thread never sleeps for more than a brief period, and will
 *	happily eat up almost all available CPU time.
 *	
 *	For your app to run effectively, you will need to
 *	also run it as a HIGH_PRIORITY_CLASS process by calling
 *	SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);
 *
 ***************************************************************************
 */


/*
 * Include files
 */

// It is the intent that this file be distributed with the sim
// for public use, so do NOT include any iRacing specific header
// files here!


namespace iRacingTelem
{
// The Microsoft Visual Studio compiler directive to cause
// structures to be packed to 1 byte alignment.  For example,
// struct { char a, float b}; would take 5 bytes, and an
// array of two of these would take 10 bytes.
#pragma pack (push, 1)

// The types of telemetry that the app can ask the sim to generate.
// The first group are sample items, and will be generated as a
// group each sampling period (60 or 360Hz).
//
// The second group are sample items, but will only be generated
// at a 60Hz period.
//
// The third group are state items, and will be generated as the
// need arises.
//
// You should never request either kNoStateInfo, or kSampleFooter,
// as they are used internally by the telemetry system.
enum eSimDataType {
	// these samples are available at either 60Hz or 360Hz as selected
	kSampleHeader,
	kChassisData,
	kDrivelineData,
	kDriverInput,

	// these samples are available at only 60Hz, even when 360Hz is selected
	kSimRateData = 64,

	// Add any new per-sample items above here.
		// The app must NOT use this data type
		kNoStateInfo = 127,

	// Add any "state" data below here.
	kCurrentWeekend,
	kDriverInCar,
	kSimIsPaused,
	kSessionInfo,
	kCarInfo,

	// DO NOT ADD ANY ITEMS BELOW HERE
	// The app must NOT use this data type.
	kSampleFooter	= 255
};


////////////////////////////////////////////////////////////////////////////
// The following data are sample items.
////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------
// Each time the driver gets into the car (including whenever they hit
// shift-R to reset the car), the sequence number will change.
// Each 60th of a second when the player physics is run, tick will
// increment by one.
// If you're requesting data at the physics rate, you'll get 6 samples
// each 60th of a second with the same tick value, but the step value
// will count from [0..5].  If you're sampling at 60Hz, step will always
// be 5.
// time counts the number of simulation seconds since sequence was
// incremented.  It does not increase while the sim is paused.
typedef struct {
	unsigned int	sequence;		// Increments each time physics is reset
	unsigned int	tick;			// Increments each 1/60th of a second
	int				step;			// From 0..N if AtPhysicsRate()
	double			time;			// Elapsed sim-world seconds since reset
} SampleHeader;


//------------------------------------------------------------------------
// World coordinates:
//		- right handed, with +z = up
// From the driver's point of view sitting at the center of gravity of the car,..
// Car coordinates:
//		- right handed, with +z = up, +x = towards nose, +y towards left side
//		- +yaw rotates the +x axis into the +y axis
//		- +pitch rotates the +z axis into the +x axis
//		- +roll rotates the +y axis into the +z axis
typedef struct {
	float			trkPct;			// Percentage of way around the track
	float			v[3];			// velocity [x,y,z] (meters/sec)
	float			q[3];			// orientation [yaw,pitch,roll] (radians)
	float			w[3];			// angular velocity [carx,cary,carz] (radians/sec)
	float			steerT;			// torque on steering shaft (N*m, + => clockwise torque)
} ChassisData;

// NOTE:
// For the chassis orientation, yaw is applied first, then pitch, then roll.
// You can generate a 3x3 rotation matrix from car coordinates to world
// coordinates from ChassisData.q as follows...
//		- Let the prefix 'c' mean cos(x), and the prefix 's' mean sin(x)
//		- Let the suffix 'y' mean yaw, 'p' mean pitch, and 'r' mean roll
// so that, for example, 'cp' means cos(pitch), or cos(ChassisData.q[1]).
// Then...
//		m[0][0] = cp*cy;
//		m[0][1] = cy*sp*sr - cr*sy;
//		m[0][2] = cr*cy*sp + sr*sy;
//		m[1][0] = cp*sy;
//		m[1][1] = cr*cy + sp*sr*sy;
//		m[1][2] = cr*sp*sy - cy*sr;
//		m[2][0] = -sp;
//		m[2][1] = cp*sr;
//		m[2][2] = cp*cr;
// Multiplying a vector by this matrix will rotate it from the car's
// coordinate system into the world coordinate system.  Multiplying
// a vector by the transpose of this matrix goes the other way.
//
// See the sample program for an example.  It computes lateral,
// longitudinal, and normal G loads from (sequences of) this data.


//------------------------------------------------------------------------
typedef struct {
	float				engRPM;		// engine RPM
} DrivelineData;

//------------------------------------------------------------------------
typedef struct {
	float				throttle;	// Percent applied
	float				brake;		// Percent applied
	float				clutch;		// Percent released (1 => foot off clutch)
	float				steer;		// Steering wheel angle in radians (+ clockwise)
	int					gear;		// reverse = <0, neutral = 0, fwd gear = >0
} DriverInput;

//------------------------------------------------------------------------
typedef struct {
	int					dummy;		// this is just a placeholder struct for now
} SimRateData;


////////////////////////////////////////////////////////////////////////////
// The following data are state items.
// They are generated at the first opportunity after
// the event occurs.  This will generally be immediate unless
// there is a data overrun in the sim telemetry buffer.
////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------
// You get one of these whenever a new set of race weekend parameters
// is proposed, or when the weekend becomes active or inactive.
// See the sim's readme.txt for a description of the .sessions
// and .options strings.  They're described in the off-line league
// section.
typedef struct {
	bool				atTrack;	// Does the sim have a track loaded?
	char				track[64];	// track directory
	float				trackLength;// meters
	char				sessions[64];// See off-line league section of
	char				options[32];// readme.txt for descriptions.
} CurrentWeekend;

//------------------------------------------------------------------------
// You will get one of these whenever the player gets into, or out of
// the car.  You might, or might not, get these messages when the
// player hits shift-R to reset the car (you get them in single player,
// you don't if the player is connected to a remote server in a
// multiplayer race).
typedef struct {
	bool				inCar;		// Is player in-car?
	float				headPos[3];	// DEPRECATED - use CarInfo.headPos
} DriverInCar;

// You will get one of these whenever the type of car that the
// driver is using changes.
typedef struct {
	float				headPos[3];		// driver's head position vector in chassis frame
	char				carPath[128];	// Directory of this car.
} CarInfo;


//------------------------------------------------------------------------
// You get one of these whenever the sim is paused or unpaused,
// even if the player is not currently driving.
typedef struct {
	bool				paused;		// Is the sim paused?
} SimIsPaused;


//------------------------------------------------------------------------
// These are the different session types.
enum eSessionType {
	kSessionTypeInvalid,
	kSessionTypeTesting,
	kSessionTypePracticeLone,
	kSessionTypePractice,
	kSessionTypeQualifyLone,
	kSessionTypeQualifyOpen,
	kSessionTypeRace
};

// Any given session will proceed through one or more of these
// session states.  Not all session types use all the states.
// During ssGetInCar, the sim is waiting for drivers to get
// into their cars before proceeding.
// ssWarmup is during "Gentlemen, start your engines!"
// ssParadeLaps is used during the pace lap at the start of the race.
// ssRacing is used during the majority of most sessions.  It
// includes caution periods during a race.
// ssCheckered us used during the period of time from when
// the checkered flag is shown to the race leader until the last
// car running takes the checkered flag.
// ssCoolDown covers the period of time after the session is
// complete until the next session starts, or the weekend is
// ended.
enum eSessionState {
	kSessionStateInvalid,
	kSessionStateGetInCar,
	kSessionStateWarmup,
	kSessionStateParadeLaps,
	kSessionStateRacing,
	kSessionStateCheckered,
	kSessionStateCoolDown
};

// The current track status - is the yellow flag out?
enum eSessionFlag {
	kFlagGreen,
	kFlagYellow,
	kFlagRed
};

// You will get a SessionInfo periodically whenever a race
// weekend is active.
// - sessionNum is the session index (the first sessionNum is 0).
// - sessionCookie will change whenever a session is restarted.
// It's pretty important that you pay attention to these two.
// Whenever the sessionNum or sessionCookie changes, you'll want
// to clear out any information you may have cached for this
// and any later sessions (like lap crossings and standings -
// see below).
// - sessionType is one of the eSessionType values above.
// - sessionState is one of the eSessionState values above.
// - sessionFlag is one of the eSessionFlag values above.
// - currentTime is the current session time - the number of
// elapsed simulation seconds since the start of the session.
// Simulation time does not advance while the sim is paused.
// Simulation time (generally) advances more quickly than
// real time when the sim is running in 'accelerated' time.
// - timeRemaining reflects what is shown on the "time remaining"
// field on the race weekend screen.  It is the number of seconds
// remaining in the current state of the current session.  It is
// possible that this value will be -1 immediately after a state
// transition
// - lapsRemaining will only be valid during sessions whose length
// is limited to a particular number of laps (qualifying and race).
typedef struct {
	int					sessionNum;
	int					sessionCookie;	// changes if session restarted
	int					sessionType;	// eSessionType
	int					sessionState;	// eSessionState
	int					sessionFlag;	// eSessionFlag
	float				currentTime;
	float				timeRemaining;
	int					lapsRemaining;
} SessionInfo;


////////////////////////////////////////////////////////////////////////////

			// Initialize the application end of the telemetry system.
			// - simName should be the name of the sim to which you want
			// to connect.  You can find this by right-clicking on
			// the simulator executable (iRacingSim.exe) and selecting
			// Properties.  On the General tab, find the Description: string.
			// Currently, this is "iRacing.com Simulator"
			// - Always leave the id parameter as it's default NULL value.
			// AppBegin will return true if it succeeds, or false otherwise.
			// The two most likely reasons that it will return false are:
			//	1: Another program is running that has called AppBegin
			//	2: The sim is running, it had already attached to a telemetry-
			//		gatherer, and that gatherer exited without calling AppEnd().
bool		AppBegin(const char *simName, const char *id = NULL);

			// Will return true if AppBegin was called successfully,
			// and AppEnd has not yet been called.
bool		AppBegunQ();

			// Will return true once the simulator has started and
			// initialized its end of the telemetry system.  It will
			// continue to return true until the sim exits, or
			// AppEnd is called.
bool		AppCheckIfSimActiveQ();

			// If you've successfully called AppBegin, you should
			// call AppEnd to clean up the application end of the
			// telemetry system before your program terminates.
			// It is not necessary for you to wait until the sim
			// exits to use AppEnd.
void		AppEnd();



			// The following three functions will write your request
			// into a buffer that the sim will read and process at
			// its convenience.  If the request will not fit in the
			// available space in the buffer, it will return false.

			// Pass true to receive samples at 360Hz, false for 60Hz.
			// By default, samples are generated at 60Hz.
bool		AppRequestDataAtPhysicsRate(bool yes);

			// The set you pass here replaces your prior request.
			// Note that you must also call AppEnableSampling() if any
			// of the data items that you've requested are sample items.
			// By default, no telemetry is generated.
bool		AppRequestDataItems(int nItems, const eSimDataType *itemTypes);

			// Pass true to enable sample generation, false to disable.
			// This only affects sample items.  Requested state items
			// will still be generated even if this is called with false.
			// By default, telemetry generation is disabled.
bool		AppEnableSampling(bool yes);




			// This is the routine you call to read telemetry (both
			// sample data, and state date) from the sim.
			// Pass a negative timeout value to wait forever (not recommended)
			// Pass 0 to return immediately once a complete sample,
			// has been read, or a state item has been read, or the
			// telemetry buffer is empty.
			// There are three possibilities when this routine returns:
			//	+ it returns true
			//		- a new sample is available.  use appGetSimData() for
			//		  each type of sample data you've requested (being
			//		  careful to test for NULL).
			//		- newStateData will be set to kNoStateInfo,
			//	+ it returns false, and newStateData != kNoStateInfo
			//		- a new piece of state data is available.  call
			//		  appGetSimData(newStateData) to examine the state data.
			//	+ it returns false, and newStateData == kNoStateInfo
			//		- no new state info was read, and there is not yet a
			//		  new sample available.  It is possible that part of
			//		  a new sample may have been read.
bool		AppWaitForNewSample(eSimDataType *newStateData, int timeoutMillisecs);

			// Clear the most recently generated sample.  It is not
			// necessary for you to call this, but you might use it to
			// prevent inadvertent reuse of a sample.
void		AppClearSample();

			// You can use this to clear a particular bit of telemetry.
void		AppClearSimData(eSimDataType dataType);

			// Access the most recently generated bit of telemetry
			// of the specified type.  See Overview discussion above
			// for importance of checking the return value for NULL.
const void	*AppGetSimData(eSimDataType dataType);

			// Determine the size of the most recently generated bit
			// of telemetry of this type.  For most items, this will
			// return either 0 if the item has been cleared, or the
			// sizeof() the item's struct.  If a particular item's
			// description indicates that the sim will generate multiple
			// copies of the item at once, then this will return
			// N * sizeof(the struct).  Currently (8-oct-2008) there
			// are no items for which multiple copies will be generated
			// at once.
int			AppGetSimDataSize(eSimDataType dataType);



			// See if the telemetry buffer has overrun.  Each time the
			// sim tries to write a bit of telemetry, and there is not
			// enough space in the buffer for it, it will set this flag.
			// Once set, this flag will remain true until you (the app)
			// clears it.
bool		AppCheckIfSimDataOverrunQ();

			// Clear the telemetry overrun flag.  
void		AppClearSimDataOverrun();



			// AppRequestDataAtPhysicsRate, AppRequestDataItems, and
			// AppEnableSampling write your requests into a small buffer
			// that the sim reads and processes at its leisure.  If you
			// call one of these functions, and it returns false, it will
			// be because this buffer is currently full.  You can call
			// this function to flag that this has happened.  The sim
			// will clear this flag whenever it reads a request from
			// the buffer.
void		AppSetAppDataOverrun();

			// Will return true if you have called AppSetAppDataOverrun,
			// and the sim has not yet cleared this flag.
bool		AppCheckIfAppDataOverrunQ();


#pragma pack(pop)
}; // namespace iRacingTelem

#endif	// #ifndef TELEMAPP_H_INCLUDED

